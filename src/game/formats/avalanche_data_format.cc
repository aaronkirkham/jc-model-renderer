#include "pch.h"

#include "avalanche_data_format.h"

#include "app/app.h"
#include "version.h"

#include "game/game.h"
#include "game/resource_manager.h"

#include "render/imguiex.h"
#include "render/renderer.h"
#include "render/ui.h"

#include <fstream>
#include <sstream>
#include <tinyxml2.h>

namespace jcmr::game::format
{
static void str_replace(std::string& data, const char* search, const char* replace)
{
    size_t pos = data.find(search);
    while (pos != std::string::npos) {
        data.replace(pos, strlen(search), replace);
        pos = data.find(search, pos + strlen(replace));
    }
}

struct AvalancheDataFormatImpl final : AvalancheDataFormat {
    AvalancheDataFormatImpl(App& app)
        : m_app(app)
    {
        app.get_ui().on_render([this](RenderContext& context) {
            std::string _adf_to_unload;
            for (auto& adf : m_adfs) {
                bool open = true;

                auto title = fmt::format("{} {}", this->get_filetype_icon(), adf.first);

                auto dock_id = m_app.get_ui().get_dockspace_id(UI::E_DOCKSPACE_RIGHT);
                ImGui::SetNextWindowDockID(dock_id, ImGuiCond_Appearing); // TODO: ImGuiCond_FirstUseEver

                if (ImGui::Begin(title.c_str(), &open, ImGuiWindowFlags_NoSavedSettings)) {
                    auto size = ImGui::GetContentRegionAvail();
                    ImGui::InputTextMultiline("##text_editor", m_src_code[adf.first].data(),
                                              m_src_code[adf.first].size(), size, ImGuiInputTextFlags_ReadOnly);
                }

                if (!open) {
                    _adf_to_unload = adf.first;
                }

                ImGui::End();
            }

            if (!_adf_to_unload.empty()) {
                unload(_adf_to_unload);
                _adf_to_unload.clear();
            }
        });
    }

    bool load(const std::string& filename) override
    {
        if (is_loaded(filename)) return true;

        LOG_INFO("AvalancheDataFormat : loading \"{}\"...", filename);

        auto* resource_manager = m_app.get_game().get_resource_manager();

        ByteArray buffer;
        if (!resource_manager->read(filename, &buffer)) {
            return false;
        }

        auto adf = std::make_unique<ava::AvalancheDataFormat::ADF>(buffer);
        generate_adf_source_code(filename, adf.get());
        m_adfs.insert({filename, std::move(adf)});
        return true;
    }

    void unload(const std::string& filename) override
    {
        auto iter = m_adfs.find(filename);
        if (iter == m_adfs.end()) return;
        m_adfs.erase(iter);
    }

    bool save(const std::string& filename, ByteArray* out_buffer) override { return false; }

    bool is_loaded(const std::string& filename) const override { return m_adfs.find(filename) != m_adfs.end(); }

    bool export_to(const std::string& filename, const std::filesystem::path& path) override
    {
        LOG_INFO("AvalancheDataFormat -> export_to({}, {})", filename, path.generic_string());
        if (!load(filename)) return false;

        // get the loaded adf
        auto iter = m_adfs.find(filename);
        if (iter == m_adfs.end()) return false;

        auto export_filename = path / std::filesystem::path(filename).filename();
        export_filename += std::string(".xml");
        std::filesystem::create_directories(export_filename.parent_path());

        tinyxml2::XMLPrinter printer;

        // write adf element
        printer.PushHeader(false, true);
        printer.PushComment(" File generated by " VER_PRODUCTNAME_STR " v" VER_PRODUCT_VERSION_STR " ");
        printer.PushComment(" https://github.com/aaronkirkham/jc-model-renderer ");
        printer.OpenElement("adf");
        {
            auto* adf    = (*iter).second.get();
            auto& header = adf->GetHeader();

            printer.PushAttribute("extension", std::filesystem::path(filename).extension().string().c_str());
            printer.PushAttribute("version", header.m_Version);
            printer.PushAttribute("flags", header.m_Flags);

            // write description (needed if we reimport later)
            {
                auto* description = (const char*)&header.m_Description;
                if (strlen(description) > 0) {
                    std::string desc(description);
                    str_replace(desc, "\n", ", ");
                    printer.PushAttribute("library", desc.c_str());
                }
            }

            // write instances
            for (u32 i = 0; i < header.m_InstanceCount; ++i) {
                ava::AvalancheDataFormat::SInstanceInfo instance{};
                if (!adf->GetInstance(i, &instance)) {
                    LOG_ERROR("AvalancheDataFormat : failed to export instance {}!", i);
                    continue;
                }

                printer.OpenElement("instance");
                {
                    printer.PushAttribute("name", instance.m_Name);
                    printer.PushAttribute("type_hash", instance.m_TypeHash);

                    if (instance.m_InstanceSize > 0) {
                        const auto* type = adf->FindType(instance.m_TypeHash);
                        write_adf_instance_to_xml(printer, &instance, adf, type);
                    } else {
                        LOG_WARNING(
                            "AvalancheDataFormat : failed to export instance {} because the type {0:x} is missing!",
                            instance.m_Name, instance.m_TypeHash);
                        printer.PushComment(" This instance couldn't be exported because the type is missing! ");
                    }
                }
                printer.CloseElement();
            }

            // write types
            auto types = adf->GetTypes(true);
            ASSERT(types.size() == header.m_TypeCount);
            if (!types.empty()) {
                printer.PushComment(" !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ");
                printer.PushComment(" !!! Internal ADF types. Do not change anything in here !!! ");
                printer.PushComment(" !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ");
                printer.OpenElement("types");

                for (auto& type : types) {
                    printer.OpenElement("type");
                    printer.PushAttribute("name", adf->GetString(type->m_Name).c_str());
                    printer.PushAttribute("type", type->m_Type);
                    printer.PushAttribute("size", type->m_Size);
                    printer.PushAttribute("align", type->m_Align);
                    printer.PushAttribute("type_hash", type->m_TypeHash);
                    printer.PushAttribute("flags", type->m_Flags);
                    printer.PushAttribute("scalar_type", type->m_ScalarType);
                    printer.PushAttribute("sub_type_hash", type->m_SubTypeHash);
                    printer.PushAttribute("array_size", type->m_ArraySize);

                    // write type members
                    if (type->m_Type == ava::EAdfType::ADF_TYPE_STRUCT
                        || type->m_Type == ava::EAdfType::ADF_TYPE_ENUM) {
                        const bool is_enum = (type->m_Type == ava::EAdfType::ADF_TYPE_ENUM);

                        for (u32 i = 0; i < type->m_MemberCount; ++i) {
                            printer.OpenElement("member");

                            if (is_enum) {
                                const auto& enum_member = type->Enum(i);
                                printer.PushAttribute("name", adf->GetString(enum_member.m_Name).c_str());
                                printer.PushAttribute("value", enum_member.m_Value);
                            } else {
                                const auto& member = type->m_Members[i];
                                printer.PushAttribute("name", adf->GetString(member.m_Name).c_str());
                                printer.PushAttribute("type_hash", member.m_TypeHash);
                                printer.PushAttribute("align", member.m_Align);
                                printer.PushAttribute("offset", member.m_Offset);
                                printer.PushAttribute("bit_offset", member.m_BitOffset);
                                printer.PushAttribute("flags", member.m_Flags);
                                printer.PushAttribute("default", member.m_DefaultValue);
                            }

                            printer.CloseElement();
                        }
                    }

                    printer.CloseElement();
                }

                printer.CloseElement();
            }
        }
        printer.CloseElement();

        std::ofstream out_stream(export_filename);
        out_stream << printer.CStr();
        out_stream.close();

        m_adfs.erase(iter);
        return true;
    }

  private:
    const std::string& type_to_string(ava::AvalancheDataFormat::ADF* adf, u32 type_hash)
    {
        auto* type = adf->FindType(type_hash);
        ASSERT(type != nullptr);
        return adf->GetString(type->m_Name);
    }

    void write_adf_instance_to_xml(tinyxml2::XMLPrinter& printer, ava::AvalancheDataFormat::SInstanceInfo* instance,
                                   ava::AvalancheDataFormat::ADF* adf, const ava::AvalancheDataFormat::AdfType* type,
                                   u32 offset = 0)
    {
        ASSERT(adf != nullptr);
        ASSERT(type != nullptr);

        // ensure offset is valid range in instance data
        const auto* data = (const u8*)instance->m_Instance;
        ASSERT(data != nullptr);
        ASSERT(offset <= instance->m_InstanceSize);

        // @NOTE - tinyxml2 uses .8g precision, avalanche use .9g.
        static auto PushHigherPrecisionFloat = [](tinyxml2::XMLPrinter& printer, float value) {
            static auto TIXML_SNPRINTF = [](char* buffer, size_t size, const char* format, ...) {
                va_list va;
                va_start(va, format);
                vsnprintf_s(buffer, size, _TRUNCATE, format, va);
                va_end(va);
            };

            char buf[200];
            TIXML_SNPRINTF(buf, 200, "%.9g", value);
            printer.PushText(buf, false);
        };

        switch (type->m_Type) {
            case ava::ADF_TYPE_SCALAR: {
                switch (type->m_ScalarType) {
                    case ava::ADF_SCALARTYPE_SIGNED:
                        switch (type->m_Size) {
                            case sizeof(i8): printer.PushText(*(i8*)&data[offset]); break;
                            case sizeof(i16): printer.PushText(*(i16*)&data[offset]); break;
                            case sizeof(i32): printer.PushText(*(i32*)&data[offset]); break;
                            case sizeof(i64): printer.PushText(*(i64*)&data[offset]); break;
                        }
                        break;
                    case ava::ADF_SCALARTYPE_UNSIGNED:
                        switch (type->m_Size) {
                            case sizeof(u8): printer.PushText(*(u8*)&data[offset]); break;
                            case sizeof(u16): printer.PushText(*(u16*)&data[offset]); break;
                            case sizeof(u32): printer.PushText(*(u32*)&data[offset]); break;
                            case sizeof(u64): printer.PushText(*(u64*)&data[offset]); break;
                        }
                        break;
                    case ava::ADF_SCALARTYPE_FLOAT:
                        switch (type->m_Size) {
                            case sizeof(float): PushHigherPrecisionFloat(printer, *(float*)&data[offset]); break;
                            case sizeof(double): printer.PushText(*(double*)&data[offset]); break;
                        }
                        break;
                }

                break;
            }

            case ava::ADF_TYPE_STRUCT: {
                printer.OpenElement("struct");
                printer.PushAttribute("type", adf->GetString(type->m_Name).c_str());

                // write members
                for (u32 i = 0; i < type->m_MemberCount; ++i) {
                    const auto& member      = type->m_Members[i];
                    const auto* member_type = adf->FindType(member.m_TypeHash);

                    if (!member_type) {
                        LOG_ERROR("AvalancheDataFormat : failed to export instance struct {} member {} due to unknown "
                                  "type {0:x} in struct!",
                                  adf->GetString(type->m_Name), adf->GetString(member.m_Name), member.m_TypeHash);
                        continue;
                    }

                    printer.OpenElement("member");
                    printer.PushAttribute("name", adf->GetString(member.m_Name).c_str());

                    if (member_type->m_Type == ava::ADF_TYPE_BITFIELD) {
                        LOG_INFO("ADF_TYPE_BITFIELD");
                    } else {
                        printer.PushAttribute("type", type_to_string(adf, member_type->m_TypeHash).c_str());
                        write_adf_instance_to_xml(printer, instance, adf, member_type, (offset + member.m_Offset));
                    }

                    printer.CloseElement();
                }

                printer.CloseElement();
                break;
            }

            case ava::ADF_TYPE_POINTER:
            case ava::ADF_TYPE_DEFERRED: {
                LOG_INFO("ADF_TYPE_POINTER/ADF_TYPE_DEFERRED");
                break;
            }

            case ava::ADF_TYPE_ARRAY: {
                const u32 rel_offset = *(u32*)&data[offset];
                const u32 count      = *(u32*)&data[offset + 8];

                const auto* sub_type = adf->FindType(type->m_SubTypeHash);
                if (!sub_type) {
                    LOG_ERROR("AvalancheDataFormat : failed to export instance array {} due to unknown sub-type {0:x}!",
                              adf->GetString(type->m_Name), type->m_SubTypeHash);
                    break;
                }

                printer.OpenElement("array");
                printer.PushAttribute("type", type_to_string(adf, sub_type->m_TypeHash).c_str());
                printer.PushAttribute("count", count); // TODO : don't write the count

                for (u32 i = 0; i < count; ++i) {
                    write_adf_instance_to_xml(printer, instance, adf, sub_type, (rel_offset + (sub_type->m_Size * i)));

                    // add a space if it's not the last element
                    if (sub_type->m_Type == ava::ADF_TYPE_SCALAR && (i != (count - 1))) {
                        printer.PushText(" ");
                    }
                }

                printer.CloseElement();
                break;
            }

            case ava::ADF_TYPE_INLINE_ARRAY: {
                const auto* sub_type = adf->FindType(type->m_SubTypeHash);
                if (!sub_type) {
                    LOG_ERROR("AvalancheDataFormat : failed to export instance inline_array {} due to unknown sub-type "
                              "{0:x}!",
                              adf->GetString(type->m_Name), type->m_SubTypeHash);
                    break;
                }

                // calculate sub type size
                auto size = sub_type->m_Size;
                if (sub_type->m_Type == ava::ADF_TYPE_STRING || sub_type->m_Type == ava::ADF_TYPE_POINTER) {
                    size = 8;
                }

                printer.OpenElement("inline_array");
                printer.PushAttribute("type", type_to_string(adf, sub_type->m_TypeHash).c_str());

                for (u32 i = 0; i < type->m_ArraySize; ++i) {
                    write_adf_instance_to_xml(printer, instance, adf, sub_type, (offset + (size * i)));

                    // add a space if it's not the last element
                    if (sub_type->m_Type == ava::ADF_TYPE_SCALAR && (i != (type->m_ArraySize - 1))) {
                        printer.PushText(" ");
                    }
                }

                printer.CloseElement();
                break;
            }

            case ava::ADF_TYPE_STRING: {
                const u32 rel_offset = *(u32*)&data[offset];
                printer.PushText((const char*)&data[rel_offset]);
                break;
            }

            case ava::ADF_TYPE_ENUM: {
                LOG_INFO("ADF_TYPE_ENUM");
                break;
            }

            case ava::ADF_TYPE_STRING_HASH: {
                printer.OpenElement("stringhash");
                {
                    const u32 hash = *(u32*)&data[offset];
                    printer.PushText(adf->HashLookup(hash));
                }
                printer.CloseElement();
                break;
            }
        }
    }

    static std::string indent(u32 count)
    {
        std::string res;
        for (u32 i = 0; i < count; ++i) {
            res += "\t";
        }
        return res;
    }

    void write_instance_to_stream(std::stringstream& stream, ava::AvalancheDataFormat::SInstanceInfo* instance,
                                  ava::AvalancheDataFormat::ADF* adf, const ava::AvalancheDataFormat::AdfType* type,
                                  u32 offset = 0, const std::string& member_name = "", u32 indents = 0,
                                  bool is_member_of_inline_array = false, bool output_indents = false)
    {
        ASSERT(adf != nullptr);
        ASSERT(type != nullptr);

        // ensure offset is valid range in instance data
        const auto* data = (const u8*)instance->m_Instance;
        ASSERT(data != nullptr);
        ASSERT(offset <= instance->m_InstanceSize);

        switch (type->m_Type) {
            case ava::ADF_TYPE_SCALAR: {
                if (!is_member_of_inline_array)
                    stream << indent(indents) << fmt::format("{} {} = ", adf->GetString(type->m_Name), member_name);
                else if (output_indents)
                    stream << indent(indents);

                switch (type->m_ScalarType) {
                    case ava::ADF_SCALARTYPE_SIGNED:
                        switch (type->m_Size) {
                            case sizeof(i8): stream << (int)*(i8*)&data[offset]; break;
                            case sizeof(i16): stream << (int)*(i16*)&data[offset]; break;
                            case sizeof(i32): stream << *(i32*)&data[offset]; break;
                            case sizeof(i64): stream << *(i64*)&data[offset]; break;
                        }
                        break;
                    case ava::ADF_SCALARTYPE_UNSIGNED:
                        switch (type->m_Size) {
                            case sizeof(u8): stream << (int)*(u8*)&data[offset]; break;
                            case sizeof(u16): stream << (int)*(u16*)&data[offset]; break;
                            case sizeof(u32): stream << *(u32*)&data[offset]; break;
                            case sizeof(u64): stream << *(u64*)&data[offset]; break;
                        }
                        break;
                    case ava::ADF_SCALARTYPE_FLOAT:
                        switch (type->m_Size) {
                            case sizeof(f32): stream << *(f32*)&data[offset]; break;
                            case sizeof(f64): stream << *(f64*)&data[offset]; break;
                        }
                        break;
                }

                if (!is_member_of_inline_array) stream << ";" << std::endl;
                break;
            }

            case ava::ADF_TYPE_STRUCT: {
                // TODO : don't output struct def if inside_inline_array
                if (offset != 0) {
                    stream << indent(indents) << fmt::format("{} {} = {{", adf->GetString(type->m_Name), member_name)
                           << std::endl;
                }

                // write members
                for (u32 i = 0; i < type->m_MemberCount; ++i) {
                    const auto& member      = type->m_Members[i];
                    const auto* member_type = adf->FindType(member.m_TypeHash);

                    if (!member_type) {
                        LOG_ERROR("AvalancheDataFormat : failed to export instance struct {} member {} due to unknown "
                                  "type {0:x} in struct!",
                                  adf->GetString(type->m_Name), adf->GetString(member.m_Name), member.m_TypeHash);
                        continue;
                    }

                    write_instance_to_stream(stream, instance, adf, member_type, (offset + member.m_Offset),
                                             adf->GetString(member.m_Name), (indents + 1));
                }

                if (offset != 0) stream << indent(indents) << "};" << std::endl;
                break;
            }

            case ava::ADF_TYPE_POINTER:
            case ava::ADF_TYPE_DEFERRED: {
                const u32 rel_offset = *(u32*)&data[offset];
                u32       type_hash  = 0xDEFE88ED;

                if (type->m_Type == ava::ADF_TYPE_POINTER) {
                    type_hash = type->m_SubTypeHash;
                } else if (rel_offset) {
                    type_hash = *(u32*)&data[offset + 8];
                }

                LOG_INFO("ADF_TYPE_POINTER/ADF_TYPE_DEFERRED ({} {})", type_to_string(adf, type_hash), member_name);

                const auto* deferred_type = adf->FindType(type_hash);

                stream << indent(indents)
                       << fmt::format("{}* {} => 0x{:X};", type_to_string(adf, type_hash), member_name, rel_offset);

                if (!is_member_of_inline_array) stream << std::endl;

                // stream << indent(indents) << "};" << std::endl;

                if (deferred_type) {
                    // WriteInstance(printer, adf, header, deferred_type, data, rel_offset);

                    // TODO : only write instance if deferred_type doesn't exist in the data!!!
                    // write_instance_to_stream(stream, instance, adf, deferred_type, rel_offset, member_name,
                    //                          (indents + 1));
                } else {
                    LOG_WARNING("ADF_TYPE_POINTER/ADF_TYPE_DEFERRED type {:x} doesn't exist in data!", type_hash);
                }

                break;
            }

            case ava::ADF_TYPE_ARRAY: {
                const u32 rel_offset = *(u32*)&data[offset];
                const u32 count      = *(u32*)&data[offset + 8];

                const auto* sub_type = adf->FindType(type->m_SubTypeHash);
                if (!sub_type) {
                    LOG_ERROR("AvalancheDataFormat : failed to export instance array {} due to unknown sub-type {0:x}!",
                              adf->GetString(type->m_Name), type->m_SubTypeHash);
                    break;
                }

                // write empty object
                if (count == 0) {
                    stream << indent(indents)
                           << fmt::format("{}[] {} = {{", type_to_string(adf, type->m_SubTypeHash), member_name)
                           << std::endl;
                    stream << indent(indents) << "};" << std::endl;
                    break;
                }

                bool is_primitive_subtype =
                    (sub_type->m_Type == ava::ADF_TYPE_SCALAR || sub_type->m_Type == ava::ADF_TYPE_STRING
                     || sub_type->m_Type == ava::ADF_TYPE_STRING_HASH);
                bool output_indents = (is_primitive_subtype && count > 4 || !is_primitive_subtype);

                stream << indent(indents) << fmt::format("{}[] {} = {{", adf->GetString(sub_type->m_Name), member_name);

                if (output_indents) {
                    stream << std::endl;
                }

                for (u32 i = 0; i < count; ++i) {
                    write_instance_to_stream(stream, instance, adf, sub_type, (rel_offset + (sub_type->m_Size * i)),
                                             member_name, indents + 1, is_primitive_subtype, output_indents);

                    // add a comma if it's not the last element
                    if (is_primitive_subtype && (i != (count - 1))) {
                        stream << ", ";
                    }

                    if (sub_type->m_Type != ava::ADF_TYPE_STRUCT && sub_type->m_Type != ava::ADF_TYPE_DEFERRED
                        && output_indents) {
                        stream << std::endl;
                    }
                }

                if (output_indents) stream << indent(indents);
                stream << "};" << std::endl;
                break;
            }

            case ava::ADF_TYPE_INLINE_ARRAY: {
                const auto* sub_type = adf->FindType(type->m_SubTypeHash);
                if (!sub_type) {
                    LOG_ERROR("AvalancheDataFormat : failed to export instance inline_array {} due to unknown sub-type "
                              "{0:x}!",
                              adf->GetString(type->m_Name), type->m_SubTypeHash);
                    break;
                }

                // calculate sub type size
                auto size = sub_type->m_Size;
                if (sub_type->m_Type == ava::ADF_TYPE_STRING || sub_type->m_Type == ava::ADF_TYPE_POINTER) {
                    size = 8;
                }

                stream << indent(indents)
                       << fmt::format("{}[{}] {} = [", adf->GetString(sub_type->m_Name), type->m_ArraySize,
                                      member_name);

                for (u32 i = 0; i < type->m_ArraySize; ++i) {
                    write_instance_to_stream(stream, instance, adf, sub_type, (offset + (size * i)), member_name,
                                             indents, true);

                    // add a space if it's not the last element
                    if (sub_type->m_Type == ava::ADF_TYPE_SCALAR && (i != (type->m_ArraySize - 1))) {
                        stream << ", ";
                    }
                }

                stream << "];" << std::endl;
                break;
            }

            case ava::ADF_TYPE_STRING: {
                const u32 rel_offset = *(u32*)&data[offset];
                stream << indent(indents)
                       << fmt::format("{} {} = \"{}\";", adf->GetString(type->m_Name), member_name,
                                      (const char*)&data[rel_offset])
                       << std::endl;
                break;
            }

            case ava::ADF_TYPE_ENUM: {
                LOG_INFO("ADF_TYPE_ENUM");
                break;
            }

            case ava::ADF_TYPE_STRING_HASH: {
                const u32 hash = *(u32*)&data[offset];

                if (!is_member_of_inline_array) {
                    stream << indent(indents)
                           << fmt::format("{} {} = \"{}\";", adf->GetString(type->m_Name), member_name,
                                          adf->HashLookup(hash))
                           << std::endl;
                } else {
                    if (output_indents) stream << indent(indents);
                    stream << fmt::format("\"{}\"", adf->HashLookup(hash));
                }

                break;
            }
        }
    }

    void generate_adf_source_code(const std::string& filename, ava::AvalancheDataFormat::ADF* adf)
    {
        auto& header = adf->GetHeader();

        std::stringstream stream;

        // write instances
        for (u32 i = 0; i < header.m_InstanceCount; ++i) {
            ava::AvalancheDataFormat::SInstanceInfo instance{};
            if (!adf->GetInstance(i, &instance)) {
                continue;
            }

            stream << fmt::format("{} \"{}\" {{", type_to_string(adf, instance.m_TypeHash), instance.m_Name)
                   << std::endl;

            const auto* type = adf->FindType(instance.m_TypeHash);
            write_instance_to_stream(stream, &instance, adf, type);

            stream << "};" << std::endl;
        }

        // std::ofstream tmp("C:/users/aaron/desktop/test.txt");
        // tmp << stream.str();
        // tmp.close();

        m_src_code[filename] = stream.str();
    }

  private:
    App& m_app;

    std::unordered_map<std::string, std::unique_ptr<ava::AvalancheDataFormat::ADF>> m_adfs;
    std::unordered_map<std::string, std::string>                                    m_src_code;
};

AvalancheDataFormat* AvalancheDataFormat::create(App& app)
{
    return new AvalancheDataFormatImpl(app);
}

void AvalancheDataFormat::destroy(AvalancheDataFormat* instance)
{
    delete instance;
}
} // namespace jcmr::game::format